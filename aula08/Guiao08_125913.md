# Exercício 1
### a)

- fork é uma função que cria um novo processo. O espaço do endereço do novo processo (child process) é uma cópia do espaço endereço do calling process (processo pai); getpid é uma função que retorna o processo ID do processo que está a chamar; getppid é uma função que retorna o processo ID do calling process (processo pai)

### b)

- i) Vão ser impressas 5 linhas no terminal
- ii) O primeiro processo começa por imprimir o Antes do fork, depois, no if, acontece uma system call ao fork, o que vai criar um novo processo (nenhum processo chega a entrar no 'perror'). Depois da criação do novo processo, é impressa a linha Quem sou eu? e de seguida o Após o fork do segundo processo, o primeiro processo sucede o segundo a imprimir as mesmas linhas.
- iii)

### c)

- Correto

# Exercício 2

### a)

- A única diferença do fork2 para o fork1 é que no fork2, conseguimos ver qual é o valor de retorno do fork, neste caso, o segundo processo tem o valor do fork = 0, e o primeiro processo tem o valor fork igual a 12928. 

### b)

- Isto acontece porque o retorno de fork() (ret) é igual ao ID do processo do filho. Logo como o processo pai tem ret > 0, ele faz sleep(1) logo manda a mensagem por último

### Tarefa1.

-![Tarefa1](screenshots/tarefa1.png)

# Exercício 3

### a)

- A system call Execl faz parte da familia de funções exec, é utilizado para substituir o processo atual por um novo programa, ou seja, quando um processo chama execl(), o seu próprio código é substituido pelo código do programa indicado, mantendo o mesmo PID. Ela pode ser chamada com um número ilimitado de parâmetros porque, cada um deles representa um argumento para o programa a ser chamado (int execl(const char *path, const char *arg0, ...,);)

### b)

- i) O primeiro parâmetro é utilizado para o sistema encontrar o arquivo executável para carregar. O segundo parâmetro é o argv[0] que é o nome pelo qual o programa vai identificar-se internamente
- ii) O comando shell equivalente à invocação é apenas ./child

### c)

- i) O printf() logo após a chamada ao sistema execl() não é lido porque o processo que estava a correr este bloco do switch (processo filho) deixou de ler o programa fork3 e passou para o programa child. O bloco default ainda é corrido porque o processo pai ainda está neste programa.

- ii) Os valores do PPID do child são diferentes antes e após o sleep, porque enquanto o child estava a fazer sleep(3), o programa do processo Pai acabou, logo o filho vai ficar com o PPID do processo adotante.

- iii) Esta anomalia acontece pois o programa em que estava a correr o processo Pai termina enquanto o programa onde está a correr o filho ainda está a correr, logo, o prompt surge após o término de fork3 e logo de seguida é impresso o útlimo print do child

### Tarefa 2.

-![Tarefa1](screenshots/tarefa2.png)

# Exercício 4.

### a)

- O system call wait() suspende a execução da thread pai até um dos seus filhos terminar; O system call waitpid() suspende a execução da thread pai até uma child (especificada pelo argumento pid) mudar de estado. A diferença entre wait e waitpid é que wait é até o filho morrer e o waitpid é quando mudar de estado.