# Exercicio 1

### a)

- O programa começa por defenir uma máscara de código 0660 que representa as permissões do utilizador (rw-), depois vem a função shmemeCreate que é responsável por criar uma região de memória partilhada. ->shmget(key_t key, size_t size, int shmflg) atributos:\
1: chave criada no reg-cri.c (usada para identirficar a memória partilhada);\
2: size, tamanho da memória partilhada a ser alocada;\
3: flags.\
De seguida o shmemConnect, tem como objetico conectar-se a um segmento de memória, -> shmget(key_t key, size_t size, premissões) parâmetros:\
1: key_t é o identificador da memória que queremos acessar\
2: size_t, tamanho do segmento de memória que desejo acessar\
3: permissões ao utilizador.\
De seguida é a função shmemDestroy, que tem objetivo remover ou destruir um segmento de memória. shmctl(int shmid, IPC_RMID, shmid_ds*)\
1: Identificador da memória;\
2: Comando para instruir o sistema a remover a memória partilhada;\
3: Retorno\
A próxima função tem coomo objetivo anexar um segmento de memória partilhada a um processo.\
Vai criar um ponteiro temporario add para armazenar o endereço de memória retornado por shmat(smid, char* NULL, 0), que tem como parametros:\
1: Identificador da memória,\
2: Endereço onde a memória será anexada\
3: Premissões de acesso que serão usadas.\
Se add for diferente de -1, operação bem sucedida, o valor de add é dado ao **pAttAdd.\
E por último temos a função shmemDettatch com objetivo de desanexar a memória partilhada do espaço de endereçamento do processo. Esta função usa o método shmdt que tem como parametro o endereço de memória partilhada que foi anexada.

### b)

- A região crítica do código encontra-se na funçaõ iter(int niter), mais especificamente no proceesso incrementador.

### c)

- Tal como no programa incrementer.c, acontece a mesma anomalia de não serem incrementadas todos os valores devido à condição de corrida que ocorre na região crítica.

### d)

- ![SemCreate](screenshots/semCreate.png)\
![SemDestroy](screenshots/semDestroy.png)\
![SemUp/Down](screenshots/SemDownUp.png)


# Exercício 2

### a)

- O programa semaphore.c começa por defenir uma máscara que representa oas permissões do utilizador (rw-).\
semCreate(int key, unsigned int snum): cria snum semáforos com id key, usa a systemcall semget() que tem como parâmetros:\
1: key_t o identificador do semáforo;\
2: int A quantidade de semáforos a ser criádos;\
3: Flags adicionais (MASK)\
De seguida o programa faz semConnect com objetivo de conectar ao semáforo, esta função tem apenas como parâmetros o identificador do semáforo. Esta função começa por iniciar uma estrutura, usada para definir operações a serem realizadasnos semáforos. Ela tem como campos :\
sem_num: número de semáforos no conjunto;\
sem_op: A operação a ser realizada (-1 é down e +1 é up);\
sem_flg: Flags adicionais, neste caso 0\
De seguida a função obtém o semgid com o semget anteriormente analisado e chama a função semop que faz um down e um up e retorna o identificador do semáforo.\
De seguida define a dunção semDestroy que tem como argumentos o  semgid e chama a systemcall semctl que destroi o semáforo.\
De seguida define o semSignal que tem como argumentos o id do semáforo que começa por definir uma estrutura sembuf com um up (1) e dá retorno ao id do semáforo com um semop(semgid, &up, 1), anteriormente analizado.\
Por fim define o semDown e o semUp que têm ambas como argumento o id do semáforo e o sindex que é o indice do semáforo especifico dentro do conjunto de semáforos no qual as operações serão organizadas. De seguida define a estrutura sembuf para fazer um down -1 ou 1, depois faz down/up.sem_num = sindex, e por último fazem um retorno do semop a usar o id do semáforo e sembuf.
